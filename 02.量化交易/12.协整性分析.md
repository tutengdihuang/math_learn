# 协整性分析：理论与应用

## 目录
1. [协整性概述](#一-协整性概述)
2. [单位根与单整](#二-单位根与单整)
3. [协整检验方法](#三-协整检验方法)
4. [误差修正模型（ECM）](#四-误差修正模型ecm)
5. [向量误差修正模型（VECM）](#五-向量误差修正模型vecm)
6. [在量化交易中的应用](#六-在量化交易中的应用)
7. [Python 实现](#七-python-实现)

---

## 一、协整性概述

### 1.1 什么是协整性

**协整性（Cointegration）**是时间序列分析中的重要概念，由 Engle 和 Granger 在 1987 年提出。

**核心定义：**

如果一组非平稳时间序列的**线性组合**是平稳的，则这些序列被称为**协整的**。

**数学表达：**

对于 $n$ 个时间序列 $\{X_{1t}\}, \{X_{2t}\}, \ldots, \{X_{nt}\}$，如果存在非零向量 $\boldsymbol{\beta} = (\beta_1, \beta_2, \ldots, \beta_n)'$，使得：

$$
Z_t = \beta_1 X_{1t} + \beta_2 X_{2t} + \cdots + \beta_n X_{nt}
$$

是平稳的，则称这 $n$ 个序列是**协整的**，$\boldsymbol{\beta}$ 称为**协整向量**。

### 1.2 协整性的直观理解

**核心思想：**

尽管单个时间序列可能是非平稳的（如随机游走），但它们的**线性组合**可能是平稳的，这意味着这些序列之间存在**长期均衡关系**。

**直观例子：**

考虑两个股票的价格序列 $P_{1t}$ 和 $P_{2t}$：
- 单独来看，两个价格序列都是非平稳的（随机游走）
- 但如果它们的价差 $P_{1t} - \beta P_{2t}$ 是平稳的，则两个价格序列是协整的
- 这意味着两个股票价格之间存在长期均衡关系，价差会围绕均值波动

### 1.3 协整性的重要性

**为什么协整性重要？**

1. **长期均衡关系**
   - 协整性揭示了非平稳序列之间的长期均衡关系
   - 即使短期偏离，长期会回到均衡

2. **避免伪回归**
   - 对非平稳序列直接回归可能导致伪回归（Spurious Regression）
   - 协整性检验可以避免这个问题

3. **统计套利**
   - 协整的资产对可以用于配对交易
   - 价差的均值回复特性提供了交易机会

4. **预测能力**
   - 协整关系可以用于长期预测
   - 误差修正模型可以捕捉短期调整

### 1.4 协整性与相关性的区别

| 特性 | 相关性 | 协整性 |
|------|--------|--------|
| **定义** | 衡量两个序列的线性关系强度 | 衡量非平稳序列的长期均衡关系 |
| **平稳性要求** | 不要求平稳 | 要求序列非平稳，但线性组合平稳 |
| **时间依赖性** | 可能随时间变化 | 长期稳定的关系 |
| **应用** | 描述短期关系 | 描述长期均衡关系 |

---

## 二、单位根与单整

### 2.1 单位根过程

**单位根过程（Unit Root Process）**是非平稳时间序列的一种重要类型。

**定义：**

如果时间序列 $\{X_t\}$ 满足：

$$
X_t = X_{t-1} + \varepsilon_t
$$

其中 $\varepsilon_t$ 是白噪声，则称 $\{X_t\}$ 是**单位根过程**（随机游走）。

**特征：**
- 非平稳
- 方差随时间增长
- 没有均值回复特性

### 2.2 单整（Integration）

**单整的定义：**

如果时间序列 $\{X_t\}$ 经过 $d$ 次差分后变为平稳序列，则称 $\{X_t\}$ 是 **$d$ 阶单整**，记为 $X_t \sim I(d)$。

**常见情况：**

- **$I(0)$**：序列本身是平稳的
- **$I(1)$**：序列一阶差分后是平稳的（最常见）
- **$I(2)$**：序列二阶差分后是平稳的（较少见）

**例子：**

- 随机游走：$X_t = X_{t-1} + \varepsilon_t$，则 $X_t \sim I(1)$
- 一阶差分：$\Delta X_t = X_t - X_{t-1} = \varepsilon_t$，则 $\Delta X_t \sim I(0)$

### 2.3 协整性的单整要求

**协整性的前提条件：**

对于 $n$ 个序列 $\{X_{1t}\}, \{X_{2t}\}, \ldots, \{X_{nt}\}$ 要存在协整关系，必须满足：

1. **所有序列具有相同的单整阶数**：$X_{it} \sim I(d)$，$i = 1, 2, \ldots, n$
2. **存在线性组合使得单整阶数降低**：$Z_t = \boldsymbol{\beta}' \mathbf{X}_t \sim I(d-b)$，其中 $b > 0$

**最常见的情况：**

- 所有序列都是 $I(1)$
- 存在线性组合是 $I(0)$（平稳）

### 2.4 单位根检验

#### 2.4.1 ADF 检验（Augmented Dickey-Fuller Test）

**ADF 检验**是最常用的单位根检验方法。

**检验方程：**

$$
\Delta X_t = \alpha + \beta t + \gamma X_{t-1} + \sum_{i=1}^{p} \delta_i \Delta X_{t-i} + \varepsilon_t
$$

**原假设和备择假设：**

- **$H_0$**：$\gamma = 0$（序列有单位根，非平稳）
- **$H_1$**：$\gamma < 0$（序列无单位根，平稳）

**判断标准：**

- 如果 p-value < 0.05：拒绝 $H_0$，序列是**平稳的**
- 如果 p-value ≥ 0.05：不能拒绝 $H_0$，序列是**非平稳的**

**检验类型：**

1. **无常数项、无趋势项**：$\alpha = 0, \beta = 0$
2. **有常数项、无趋势项**：$\alpha \neq 0, \beta = 0$
3. **有常数项、有趋势项**：$\alpha \neq 0, \beta \neq 0$

#### 2.4.2 PP 检验（Phillips-Perron Test）

**PP 检验**是另一种单位根检验方法，对序列相关和异方差更稳健。

**特点：**
- 不需要指定滞后阶数
- 对序列相关和异方差更稳健
- 但可能在小样本下表现不佳

#### 2.4.3 KPSS 检验

**KPSS 检验**的原假设与 ADF 检验相反。

**原假设和备择假设：**

- **$H_0$**：序列是平稳的
- **$H_1$**：序列是非平稳的

**判断标准：**

- 如果 p-value < 0.05：拒绝 $H_0$，序列是**非平稳的**
- 如果 p-value ≥ 0.05：不能拒绝 $H_0$，序列是**平稳的**

**建议：**
- 同时使用 ADF 和 KPSS 检验
- 如果两个检验结果一致，结论更可靠

---

## 三、协整检验方法

### 3.1 Engle-Granger 两步法

#### 3.1.1 方法概述

**Engle-Granger 两步法**是最早提出的协整检验方法，适用于**两个变量**的情况。

#### 3.1.2 第一步：估计长期关系

**回归方程：**

$$
Y_t = \alpha + \beta X_t + \varepsilon_t
$$

使用 OLS 估计参数 $\alpha$ 和 $\beta$，得到残差：

$$
\hat{\varepsilon}_t = Y_t - \hat{\alpha} - \hat{\beta} X_t
$$

#### 3.1.3 第二步：检验残差的平稳性

**对残差进行 ADF 检验：**

$$
\Delta \hat{\varepsilon}_t = \gamma \hat{\varepsilon}_{t-1} + \sum_{i=1}^{p} \delta_i \Delta \hat{\varepsilon}_{t-i} + u_t
$$

**原假设和备择假设：**

- **$H_0$**：残差有单位根（无协整关系）
- **$H_1$**：残差无单位根（有协整关系）

**判断标准：**

- 如果 p-value < 0.05：拒绝 $H_0$，**存在协整关系**
- 如果 p-value ≥ 0.05：不能拒绝 $H_0$，**不存在协整关系**

#### 3.1.4 注意事项

**Engle-Granger 方法的局限性：**

1. **只适用于两个变量**
2. **依赖于第一步的估计**：如果第一步估计有偏，第二步检验可能不准确
3. **需要确定哪个变量作为因变量**：不同的选择可能得到不同的结果
4. **临界值需要特殊处理**：残差的 ADF 检验临界值与标准 ADF 检验不同

### 3.2 Johansen 检验

#### 3.2.1 方法概述

**Johansen 检验**适用于**多个变量**的协整检验，基于向量自回归（VAR）模型。

#### 3.2.2 VAR 模型

**VAR(p) 模型：**

$$
\mathbf{X}_t = \boldsymbol{\Pi}_1 \mathbf{X}_{t-1} + \boldsymbol{\Pi}_2 \mathbf{X}_{t-2} + \cdots + \boldsymbol{\Pi}_p \mathbf{X}_{t-p} + \boldsymbol{\varepsilon}_t
$$

其中 $\mathbf{X}_t$ 是 $n \times 1$ 向量。

**误差修正形式（VECM）：**

$$
\Delta \mathbf{X}_t = \boldsymbol{\Pi} \mathbf{X}_{t-1} + \sum_{i=1}^{p-1} \boldsymbol{\Gamma}_i \Delta \mathbf{X}_{t-i} + \boldsymbol{\varepsilon}_t
$$

其中：
- $\boldsymbol{\Pi} = \boldsymbol{\alpha} \boldsymbol{\beta}'$
- $\boldsymbol{\alpha}$：调整速度矩阵（$n \times r$）
- $\boldsymbol{\beta}$：协整向量矩阵（$n \times r$）
- $r$：协整关系的个数

#### 3.2.3 检验统计量

**Johansen 检验使用两个统计量：**

1. **迹统计量（Trace Statistic）：**

$$
\lambda_{trace}(r) = -T \sum_{i=r+1}^{n} \ln(1 - \hat{\lambda}_i)
$$

检验原假设：协整关系的个数 $\leq r$

2. **最大特征值统计量（Maximum Eigenvalue Statistic）：**

$$
\lambda_{max}(r, r+1) = -T \ln(1 - \hat{\lambda}_{r+1})
$$

检验原假设：协整关系的个数 $= r$

其中 $\hat{\lambda}_i$ 是 $\boldsymbol{\Pi}$ 矩阵的特征值。

#### 3.2.4 检验步骤

1. **确定 VAR 模型的滞后阶数**（使用信息准则）
2. **估计 VECM 模型**
3. **计算特征值**
4. **计算检验统计量**
5. **与临界值比较**

**判断标准：**

- 如果统计量 > 临界值：拒绝原假设，存在协整关系
- 如果统计量 ≤ 临界值：不能拒绝原假设

#### 3.2.5 Johansen 检验的优势

**相对于 Engle-Granger 方法的优势：**

1. ✅ **适用于多个变量**
2. ✅ **可以确定协整关系的个数**
3. ✅ **不依赖于变量的选择**
4. ✅ **可以识别多个协整向量**

### 3.3 ARDL 边界检验

#### 3.3.1 方法概述

**ARDL 边界检验（ARDL Bounds Test）**适用于变量具有**不同单整阶数**的情况。

#### 3.3.2 ARDL 模型

**ARDL(p,q) 模型：**

$$
Y_t = \alpha + \sum_{i=1}^{p} \phi_i Y_{t-i} + \sum_{j=0}^{q} \boldsymbol{\beta}_j' \mathbf{X}_{t-j} + \varepsilon_t
$$

#### 3.3.3 边界检验

**检验长期关系是否存在：**

使用 F 统计量检验所有滞后水平项的系数是否为零。

**判断标准：**

- 如果 F 统计量 > 上界：存在长期关系
- 如果 F 统计量 < 下界：不存在长期关系
- 如果 F 统计量在上下界之间：不确定

---

## 四、误差修正模型（ECM）

### 4.1 误差修正模型的基本思想

**误差修正模型（Error Correction Model, ECM）**是协整关系的动态表示。

**核心思想：**

如果两个序列是协整的，它们的短期动态可以通过**误差修正机制**来描述：
- **长期关系**：$Y_t = \alpha + \beta X_t$（协整关系）
- **短期调整**：当偏离长期关系时，系统会调整回到均衡

### 4.2 ECM 模型的形式

#### 4.2.1 两变量 ECM

**对于协整关系 $Y_t = \alpha + \beta X_t + \varepsilon_t$，ECM 模型为：**

$$
\Delta Y_t = \gamma_0 + \gamma_1 \Delta X_t + \lambda (Y_{t-1} - \alpha - \beta X_{t-1}) + u_t
$$

**解释：**

- $\Delta Y_t$：$Y_t$ 的一阶差分（短期变化）
- $\Delta X_t$：$X_t$ 的一阶差分（短期变化）
- $Y_{t-1} - \alpha - \beta X_{t-1}$：**误差修正项（ECT）**，表示对长期均衡的偏离
- $\lambda$：**调整速度系数**，衡量系统回到均衡的速度
  - $\lambda < 0$：系统会调整回到均衡（正常情况）
  - $|\lambda|$ 越大，调整速度越快

#### 4.2.2 ECM 的估计

**两步估计法：**

1. **第一步**：估计长期关系 $Y_t = \alpha + \beta X_t + \varepsilon_t$，得到残差 $\hat{\varepsilon}_t$
2. **第二步**：估计 ECM 模型：

$$
\Delta Y_t = \gamma_0 + \gamma_1 \Delta X_t + \lambda \hat{\varepsilon}_{t-1} + u_t
$$

**一步估计法：**

直接估计：

$$
\Delta Y_t = \gamma_0 + \gamma_1 \Delta X_t + \lambda Y_{t-1} + \delta X_{t-1} + u_t
$$

然后从估计结果中恢复长期关系。

### 4.3 ECM 的经济含义

**误差修正机制：**

1. **长期均衡**：$Y_t = \alpha + \beta X_t$
2. **短期偏离**：$Y_t - \alpha - \beta X_t \neq 0$
3. **误差修正**：系统通过调整 $\Delta Y_t$ 来减少偏离

**调整速度：**

- 如果 $|\lambda|$ 接近 1：调整很快
- 如果 $|\lambda|$ 接近 0：调整很慢
- 如果 $\lambda = 0$：没有误差修正机制（无协整关系）

### 4.4 ECM 的应用

**ECM 模型的优势：**

1. ✅ **同时捕捉长期和短期关系**
2. ✅ **提供调整速度信息**
3. ✅ **可以用于预测**
4. ✅ **理论解释清晰**

---

## 五、向量误差修正模型（VECM）

### 5.1 VECM 的基本形式

**向量误差修正模型（Vector Error Correction Model, VECM）**是多个变量的 ECM 模型。

**VECM 模型：**

$$
\Delta \mathbf{X}_t = \boldsymbol{\alpha} \boldsymbol{\beta}' \mathbf{X}_{t-1} + \sum_{i=1}^{p-1} \boldsymbol{\Gamma}_i \Delta \mathbf{X}_{t-i} + \boldsymbol{\varepsilon}_t
$$

其中：
- $\mathbf{X}_t$：$n \times 1$ 向量
- $\boldsymbol{\alpha}$：$n \times r$ 调整速度矩阵
- $\boldsymbol{\beta}$：$n \times r$ 协整向量矩阵
- $r$：协整关系的个数

### 5.2 VECM 的解释

**误差修正项：**

$\boldsymbol{\beta}' \mathbf{X}_{t-1}$ 表示对长期均衡的偏离。

**调整速度：**

$\boldsymbol{\alpha}$ 矩阵的元素表示每个变量对偏离的调整速度。

### 5.3 VECM 的估计

**估计步骤：**

1. **确定协整关系的个数**（使用 Johansen 检验）
2. **估计协整向量** $\boldsymbol{\beta}$
3. **估计调整速度矩阵** $\boldsymbol{\alpha}$
4. **估计短期动态参数** $\boldsymbol{\Gamma}_i$

---

## 六、在量化交易中的应用

### 6.1 配对交易（Pairs Trading）

#### 6.1.1 策略原理

**配对交易**是基于协整性的经典统计套利策略。

**基本步骤：**

1. **寻找协整的资产对**
   - 使用协整检验（Engle-Granger 或 Johansen）
   - 选择协整关系显著的资产对

2. **估计对冲比例**
   - 使用 OLS 回归：$P_{1t} = \alpha + \beta P_{2t} + \varepsilon_t$
   - $\beta$ 是对冲比例

3. **计算价差**
   - 价差：$Spread_t = P_{1t} - \beta P_{2t}$
   - 价差应该是平稳的（均值回复）

4. **交易信号**
   - 当价差偏离均值超过阈值时开仓
   - 当价差回到均值时平仓

#### 6.1.2 交易规则

**开仓规则：**

- **做多价差**：当 $Spread_t < \mu - k\sigma$ 时
  - 买入资产1，卖出 $\beta$ 份资产2
- **做空价差**：当 $Spread_t > \mu + k\sigma$ 时
  - 卖出资产1，买入 $\beta$ 份资产2

其中：
- $\mu$：价差的均值
- $\sigma$：价差的标准差
- $k$：阈值倍数（通常为 2）

**平仓规则：**

- 当价差回到均值时平仓
- 或设置止损和止盈

#### 6.1.3 风险管理

**注意事项：**

1. **协整关系可能破裂**
   - 定期重新检验协整关系
   - 如果协整关系消失，停止交易

2. **价差可能长期偏离**
   - 设置止损
   - 监控价差的变化

3. **流动性风险**
   - 确保两个资产都有足够的流动性
   - 考虑交易成本

### 6.2 统计套利

**统计套利**是配对交易的扩展，可以涉及多个资产。

**方法：**

1. **寻找协整的投资组合**
2. **构建市场中性组合**
3. **利用价差的均值回复特性**

### 6.3 其他应用

**1. 资产定价模型**

- 使用协整关系估计资产的长期均衡价格
- 识别价格偏离

**2. 风险管理**

- 识别资产之间的长期关系
- 构建对冲组合

**3. 市场效率检验**

- 检验价格是否偏离长期均衡
- 评估市场效率

---

## 七、Python 实现

### 7.1 单位根检验

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller, kpss
import warnings
warnings.filterwarnings('ignore')

def unit_root_test(series, test_type='adf'):
    """
    单位根检验
    
    参数:
        series: 时间序列
        test_type: 'adf' 或 'kpss'
    """
    if test_type == 'adf':
        result = adfuller(series.dropna())
        print("ADF 检验结果:")
        print(f"ADF 统计量: {result[0]:.6f}")
        print(f"p-value: {result[1]:.6f}")
        print(f"临界值: {result[4]}")
        
        if result[1] < 0.05:
            print("✅ 拒绝原假设，序列是平稳的")
        else:
            print("❌ 不能拒绝原假设，序列是非平稳的")
    
    elif test_type == 'kpss':
        result = kpss(series.dropna(), regression='ct')
        print("KPSS 检验结果:")
        print(f"KPSS 统计量: {result[0]:.6f}")
        print(f"p-value: {result[1]:.6f}")
        print(f"临界值: {result[3]}")
        
        if result[1] < 0.05:
            print("❌ 拒绝原假设，序列是非平稳的")
        else:
            print("✅ 不能拒绝原假设，序列是平稳的")
    
    return result

# 使用示例
# result = unit_root_test(price_series, test_type='adf')
```

### 7.2 Engle-Granger 协整检验

```python
from statsmodels.tsa.stattools import coint
from statsmodels.regression.linear_model import OLS

def engle_granger_test(y, x):
    """
    Engle-Granger 协整检验
    
    参数:
        y: 因变量序列
        x: 自变量序列
    """
    print("=" * 60)
    print("Engle-Granger 协整检验")
    print("=" * 60)
    
    # 第一步：估计长期关系
    print("\n第一步：估计长期关系")
    print("-" * 60)
    model = OLS(y, x).fit()
    alpha = model.params[0]
    beta = model.params[1] if len(model.params) > 1 else 0
    
    print(f"回归方程: y = {alpha:.6f} + {beta:.6f} * x")
    print(f"R-squared: {model.rsquared:.4f}")
    
    # 计算残差
    residuals = y - model.fittedvalues
    
    # 第二步：检验残差的平稳性
    print("\n第二步：检验残差的平稳性 (ADF 检验)")
    print("-" * 60)
    adf_result = adfuller(residuals.dropna())
    print(f"ADF 统计量: {adf_result[0]:.6f}")
    print(f"p-value: {adf_result[1]:.6f}")
    
    if adf_result[1] < 0.05:
        print("✅ 残差是平稳的，存在协整关系")
        is_cointegrated = True
    else:
        print("❌ 残差是非平稳的，不存在协整关系")
        is_cointegrated = False
    
    # 使用 statsmodels 的 coint 函数（推荐）
    print("\n使用 statsmodels.coint 函数:")
    print("-" * 60)
    coint_result = coint(y, x)
    print(f"协整统计量: {coint_result[0]:.6f}")
    print(f"p-value: {coint_result[1]:.6f}")
    print(f"临界值: {coint_result[2]}")
    
    if coint_result[1] < 0.05:
        print("✅ 存在协整关系")
    else:
        print("❌ 不存在协整关系")
    
    return {
        'is_cointegrated': is_cointegrated,
        'alpha': alpha,
        'beta': beta,
        'residuals': residuals,
        'coint_result': coint_result
    }

# 使用示例
# result = engle_granger_test(price1, price2)
```

### 7.3 Johansen 协整检验

```python
from statsmodels.tsa.vector_ar.vecm import coint_johansen

def johansen_test(data, det_order=0, k_ar_diff=1):
    """
    Johansen 协整检验
    
    参数:
        data: 数据矩阵 (T x n)，每列是一个变量
        det_order: 确定性项的阶数
                  0: 无常数项
                  -1: 无确定性项
                  1: 有常数项
    """
    print("=" * 60)
    print("Johansen 协整检验")
    print("=" * 60)
    
    result = coint_johansen(data, det_order, k_ar_diff)
    
    print(f"\n特征值: {result.eig}")
    print(f"\n迹统计量: {result.lr1}")
    print(f"最大特征值统计量: {result.lr2}")
    print(f"\n临界值 (迹统计量): {result.cvt[:, 0]}")
    print(f"临界值 (最大特征值统计量): {result.cvt[:, 1]}")
    
    # 判断协整关系的个数
    n = data.shape[1]
    print(f"\n协整关系检验:")
    print("-" * 60)
    
    for r in range(n):
        trace_stat = result.lr1[r]
        trace_cv = result.cvt[r, 0]
        max_eig_stat = result.lr2[r]
        max_eig_cv = result.cvt[r, 1]
        
        print(f"\nr = {r}:")
        print(f"  迹统计量: {trace_stat:.4f} (临界值: {trace_cv:.4f})")
        print(f"  最大特征值统计量: {max_eig_stat:.4f} (临界值: {max_eig_cv:.4f})")
        
        if trace_stat > trace_cv:
            print(f"  ✅ 拒绝 H0: 协整关系个数 <= {r}")
        else:
            print(f"  ❌ 不能拒绝 H0: 协整关系个数 <= {r}")
    
    # 协整向量
    print(f"\n协整向量 (标准化):")
    print(result.evec)
    
    return result

# 使用示例
# data = np.column_stack([price1, price2, price3])
# result = johansen_test(data, det_order=0, k_ar_diff=1)
```

### 7.4 误差修正模型（ECM）

```python
from statsmodels.regression.linear_model import OLS
import statsmodels.api as sm

def estimate_ecm(y, x):
    """
    估计误差修正模型 (ECM)
    
    参数:
        y: 因变量序列
        x: 自变量序列
    """
    print("=" * 60)
    print("误差修正模型 (ECM) 估计")
    print("=" * 60)
    
    # 第一步：估计长期关系
    print("\n第一步：估计长期关系")
    print("-" * 60)
    long_run_model = OLS(y, sm.add_constant(x)).fit()
    alpha = long_run_model.params[0]
    beta = long_run_model.params[1]
    residuals = long_run_model.resid
    
    print(f"长期关系: y = {alpha:.6f} + {beta:.6f} * x")
    print(f"R-squared: {long_run_model.rsquared:.4f}")
    
    # 第二步：估计 ECM 模型
    print("\n第二步：估计 ECM 模型")
    print("-" * 60)
    
    # 准备数据
    dy = y.diff().dropna()
    dx = x.diff().dropna()
    ecm_term = residuals.shift(1).dropna()
    
    # 对齐数据
    min_len = min(len(dy), len(dx), len(ecm_term))
    dy = dy.iloc[-min_len:]
    dx = dx.iloc[-min_len:]
    ecm_term = ecm_term.iloc[-min_len:]
    
    # 构建 ECM 模型
    X_ecm = pd.DataFrame({
        'dx': dx.values,
        'ecm': ecm_term.values
    })
    X_ecm = sm.add_constant(X_ecm)
    
    ecm_model = OLS(dy.values, X_ecm).fit()
    
    print(ecm_model.summary())
    
    # 解释结果
    lambda_coef = ecm_model.params['ecm']
    print(f"\n误差修正系数 (λ): {lambda_coef:.6f}")
    
    if lambda_coef < 0:
        print("✅ 存在误差修正机制，系统会调整回到均衡")
        print(f"调整速度: {abs(lambda_coef):.4f}")
    else:
        print("❌ 不存在误差修正机制")
    
    return {
        'long_run_model': long_run_model,
        'ecm_model': ecm_model,
        'alpha': alpha,
        'beta': beta,
        'lambda': lambda_coef
    }

# 使用示例
# ecm_result = estimate_ecm(price1, price2)
```

### 7.5 配对交易策略实现

```python
def pairs_trading_strategy(price1, price2, entry_threshold=2, exit_threshold=0.5):
    """
    配对交易策略
    
    参数:
        price1: 资产1的价格序列
        price2: 资产2的价格序列
        entry_threshold: 开仓阈值（标准差倍数）
        exit_threshold: 平仓阈值（标准差倍数）
    """
    print("=" * 60)
    print("配对交易策略")
    print("=" * 60)
    
    # 1. 协整检验
    print("\n1. 协整检验")
    print("-" * 60)
    coint_result = coint(price1, price2)
    
    if coint_result[1] >= 0.05:
        print("❌ 两个序列不是协整的，不适合配对交易")
        return None
    
    print("✅ 两个序列是协整的")
    
    # 2. 估计对冲比例
    print("\n2. 估计对冲比例")
    print("-" * 60)
    model = OLS(price1, sm.add_constant(price2)).fit()
    beta = model.params[1]
    print(f"对冲比例 (β): {beta:.6f}")
    
    # 3. 计算价差
    spread = price1 - beta * price2
    spread_mean = spread.mean()
    spread_std = spread.std()
    
    print(f"\n价差统计:")
    print(f"均值: {spread_mean:.6f}")
    print(f"标准差: {spread_std:.6f}")
    
    # 4. 标准化价差
    normalized_spread = (spread - spread_mean) / spread_std
    
    # 5. 生成交易信号
    positions = pd.Series(0, index=price1.index)
    
    # 做多价差（价差低于下界）
    long_entry = normalized_spread < -entry_threshold
    long_exit = normalized_spread > -exit_threshold
    
    # 做空价差（价差高于上界）
    short_entry = normalized_spread > entry_threshold
    short_exit = normalized_spread < exit_threshold
    
    # 构建仓位
    position = 0
    for i in range(len(positions)):
        if long_entry.iloc[i] and position == 0:
            position = 1  # 做多价差
        elif long_exit.iloc[i] and position == 1:
            position = 0  # 平仓
        elif short_entry.iloc[i] and position == 0:
            position = -1  # 做空价差
        elif short_exit.iloc[i] and position == -1:
            position = 0  # 平仓
        
        positions.iloc[i] = position
    
    # 6. 计算收益
    returns1 = price1.pct_change()
    returns2 = price2.pct_change()
    
    # 策略收益：做多价差时，买入资产1，卖出β份资产2
    strategy_returns = positions.shift(1) * (returns1 - beta * returns2)
    strategy_returns = strategy_returns.fillna(0)
    
    cumulative_returns = (1 + strategy_returns).cumprod()
    
    print(f"\n策略表现:")
    print(f"总收益: {(cumulative_returns.iloc[-1] - 1) * 100:.2f}%")
    print(f"年化收益: {(cumulative_returns.iloc[-1] ** (252/len(strategy_returns)) - 1) * 100:.2f}%")
    print(f"夏普比率: {strategy_returns.mean() / strategy_returns.std() * np.sqrt(252):.4f}")
    
    return {
        'spread': spread,
        'normalized_spread': normalized_spread,
        'positions': positions,
        'strategy_returns': strategy_returns,
        'cumulative_returns': cumulative_returns,
        'beta': beta
    }

# 使用示例
# strategy_result = pairs_trading_strategy(price1, price2, entry_threshold=2, exit_threshold=0.5)
```

### 7.6 完整的协整分析流程

```python
def cointegration_analysis(price1, price2, price1_name="资产1", price2_name="资产2"):
    """
    完整的协整分析流程
    """
    print("=" * 80)
    print("协整分析完整流程")
    print("=" * 80)
    
    # 1. 单位根检验
    print(f"\n1. 单位根检验")
    print("=" * 80)
    print(f"\n{price1_name}:")
    unit_root_test(price1, test_type='adf')
    print(f"\n{price2_name}:")
    unit_root_test(price2, test_type='adf')
    
    # 2. 协整检验
    print(f"\n2. 协整检验 (Engle-Granger)")
    print("=" * 80)
    eg_result = engle_granger_test(price1, price2)
    
    if not eg_result['is_cointegrated']:
        print("\n❌ 不存在协整关系，分析结束")
        return None
    
    # 3. 误差修正模型
    print(f"\n3. 误差修正模型 (ECM)")
    print("=" * 80)
    ecm_result = estimate_ecm(price1, price2)
    
    # 4. 配对交易策略
    print(f"\n4. 配对交易策略")
    print("=" * 80)
    strategy_result = pairs_trading_strategy(price1, price2)
    
    return {
        'eg_result': eg_result,
        'ecm_result': ecm_result,
        'strategy_result': strategy_result
    }

# 使用示例
# result = cointegration_analysis(price1, price2, "股票A", "股票B")
```

---

## 总结

### 核心要点

1. **协整性的定义**：非平稳序列的线性组合是平稳的

2. **前提条件**：所有序列必须具有相同的单整阶数（通常为 $I(1)$）

3. **检验方法**：
   - **Engle-Granger**：适用于两个变量
   - **Johansen**：适用于多个变量，可以确定协整关系的个数

4. **误差修正模型**：描述协整关系的短期动态调整

5. **应用**：配对交易、统计套利、风险管理

### 协整性分析的优势

- ✅ **揭示长期均衡关系**：即使序列非平稳，也能找到长期关系
- ✅ **避免伪回归**：协整检验可以避免非平稳序列回归的问题
- ✅ **统计套利**：为配对交易提供理论基础
- ✅ **预测能力**：误差修正模型可以用于预测

### 注意事项

- ⚠️ **协整关系可能破裂**：需要定期重新检验
- ⚠️ **样本量要求**：协整检验需要足够的样本量
- ⚠️ **参数稳定性**：协整向量可能随时间变化
- ⚠️ **交易成本**：实际交易中需要考虑交易成本

---

*协整性分析是时间序列分析中的重要工具，特别适用于金融时间序列的长期关系分析和统计套利策略。理解协整性的原理和应用，对于量化交易和风险管理至关重要。*

