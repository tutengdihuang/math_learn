# 平稳性与均值回复：量化交易中的核心概念

## 目录
1. [平稳性基础](#一-平稳性基础)
2. [均值回复理论](#二-均值回复理论)
3. [平稳性与均值回复的关系](#三-平稳性与均值回复的关系)
4. [检验方法](#四-检验方法)
5. [在量化交易中的应用](#五-在量化交易中的应用)
6. [实战案例与策略](#六-实战案例与策略)
7. [Python 实现](#七-python-实现)

---

## 一、平稳性基础

### 1.1 什么是平稳性？

**平稳性（Stationarity）**是时间序列分析中的核心概念，指时间序列的统计特性不随时间变化。

### 1.2 严格平稳（Strict Stationarity）

如果时间序列 $\{X_t\}$ 的**所有有限维联合分布**都不随时间平移而改变，则称该序列是严格平稳的。

**数学定义：**
对于任意 $n$ 个时刻 $t_1, t_2, \dots, t_n$ 和任意整数 $h$，有：
$$
F_{X_{t_1}, X_{t_2}, \dots, X_{t_n}}(x_1, x_2, \dots, x_n) = F_{X_{t_1+h}, X_{t_2+h}, \dots, X_{t_n+h}}(x_1, x_2, \dots, x_n)
$$

其中 $F$ 表示联合分布函数。

### 1.3 弱平稳（Weak Stationarity / Covariance Stationarity）

**弱平稳**是更实用的定义，只要求**一阶矩和二阶矩**不随时间变化：

**条件：**
1. **均值恒定**：$E[X_t] = \mu$（对所有 $t$ 都相同）
2. **方差恒定**：$\text{Var}(X_t) = \sigma^2$（对所有 $t$ 都相同）
3. **自协方差只依赖于滞后阶数**：$\text{Cov}(X_t, X_{t-k}) = \gamma_k$（只依赖于 $k$，不依赖于 $t$）

**数学表达：**
$$
\begin{align}
E[X_t] &= \mu \quad \text{(常数)} \\
\text{Var}(X_t) &= \sigma^2 \quad \text{(常数)} \\
\text{Cov}(X_t, X_{t-k}) &= \gamma_k \quad \text{(只依赖于 } k \text{)}
\end{align}
$$

### 1.4 平稳性的重要性

| 重要性 | 说明 |
|--------|------|
| **模型适用性** | AR、MA、ARMA 等模型都要求序列是平稳的 |
| **统计推断** | 平稳序列的统计推断才有意义 |
| **预测能力** | 只有平稳序列才能进行可靠的预测 |
| **参数估计** | 平稳性是参数估计一致性的前提 |

### 1.5 非平稳序列的常见类型

| 类型 | 特征 | 示例 |
|------|------|------|
| **趋势** | 均值随时间变化 | 股价长期上涨趋势 |
| **季节性** | 周期性模式 | 零售销售额的季节性波动 |
| **单位根** | 随机游走 | 股价的对数价格 |
| **结构突变** | 均值或方差突然改变 | 金融危机前后的波动率 |

---

## 二、均值回复理论

### 2.1 什么是均值回复？

**均值回复（Mean Reversion）**是指时间序列倾向于回到其长期均值或均衡水平的特性。

### 2.2 数学定义

一个均值回复过程可以表示为：

$$
X_t - \mu = \phi(X_{t-1} - \mu) + \varepsilon_t
$$

其中：
- $\mu$ 是长期均值
- $\phi$ 是均值回复速度（通常 $|\phi| < 1$）
- $\varepsilon_t$ 是白噪声

**均值回复条件：**
- 当 $0 < \phi < 1$ 时，过程是**平稳的**，具有均值回复特性
- 当 $\phi = 1$ 时，过程是**随机游走**（非平稳）
- 当 $\phi > 1$ 时，过程是**爆炸性的**（非平稳）

### 2.3 Ornstein-Uhlenbeck (OU) 过程

在连续时间中，均值回复过程常用 **Ornstein-Uhlenbeck 过程**描述：

$$
dX_t = \theta(\mu - X_t)dt + \sigma dW_t
$$

其中：
- $\theta > 0$：均值回复速度
- $\mu$：长期均值
- $\sigma$：波动率
- $dW_t$：布朗运动

**离散化形式（AR(1)）：**
$$
X_t = \mu + \phi(X_{t-1} - \mu) + \varepsilon_t
$$

其中 $\phi = e^{-\theta \Delta t}$，$\Delta t$ 是时间间隔。

### 2.4 均值回复的直观理解

**类比：**
- **弹簧模型**：价格像弹簧一样，偏离平衡位置后会回到平衡位置
- **钟摆**：价格在均值附近摆动
- **温度调节**：系统有自我调节机制

**特征：**
- ✅ 偏离均值后，有回到均值的趋势
- ✅ 波动是**有界的**（不会无限偏离）
- ✅ 长期来看，价格围绕均值波动

### 2.5 均值回复 vs 趋势

| 特性 | 均值回复 | 趋势 |
|------|----------|------|
| **长期行为** | 围绕均值波动 | 持续上升或下降 |
| **可预测性** | 短期可预测 | 方向可预测 |
| **平稳性** | 通常是平稳的 | 非平稳 |
| **交易策略** | 反转策略 | 趋势跟踪策略 |

---

## 三、平稳性与均值回复的关系

### 3.1 核心关系

**平稳性是均值回复的充分条件，但不是必要条件。**

| 关系 | 说明 | 示例 |
|------|------|------|
| **平稳 + 均值回复** | 最常见的情况 | AR(1) 模型（$|\phi| < 1$） |
| **平稳但非均值回复** | 可能但少见 | 某些特殊的平稳过程 |
| **均值回复但非平稳** | 理论上可能 | 某些非平稳但具有均值回复特性的过程 |
| **非平稳 + 非均值回复** | 随机游走 | 股价的对数价格 |

### 3.2 AR(1) 模型的平稳性与均值回复

考虑 AR(1) 模型：
$$
X_t = c + \phi X_{t-1} + \varepsilon_t
$$

**平稳性条件：**
- 当 $|\phi| < 1$ 时，过程是**平稳的**
- 当 $|\phi| = 1$ 时，过程是**单位根过程**（非平稳）
- 当 $|\phi| > 1$ 时，过程是**爆炸性的**（非平稳）

**均值回复特性：**
- 当 $0 < \phi < 1$ 时，具有**均值回复**特性
- 长期均值为：$\mu = \frac{c}{1-\phi}$
- 均值回复速度为：$\theta = -\ln(\phi)$

### 3.3 协整（Cointegration）

**协整**是处理非平稳序列均值回复的重要概念：

如果两个非平稳序列 $X_t$ 和 $Y_t$ 的线性组合 $Z_t = X_t - \beta Y_t$ 是平稳的，则称 $X_t$ 和 $Y_t$ 是**协整的**。

**在量化交易中的应用：**
- **配对交易**：寻找协整的股票对
- **统计套利**：利用价差的均值回复特性

---

## 四、检验方法

### 4.1 平稳性检验

#### ADF 检验（Augmented Dickey-Fuller Test）

**原理：** 检验序列是否存在单位根

**假设：**
- $H_0$：序列有单位根（非平稳）
- $H_1$：序列无单位根（平稳）

**判断标准：**
- 如果 p-value < 0.05，拒绝 $H_0$，序列是**平稳的**
- 如果 p-value ≥ 0.05，不能拒绝 $H_0$，序列是**非平稳的**

#### KPSS 检验

**原理：** 检验序列是否围绕确定性趋势平稳

**假设：**
- $H_0$：序列是平稳的
- $H_1$：序列是非平稳的

**判断标准：**
- 如果 p-value < 0.05，拒绝 $H_0$，序列是**非平稳的**
- 如果 p-value ≥ 0.05，不能拒绝 $H_0$，序列是**平稳的**

### 4.2 均值回复检验

#### 半衰期（Half-Life）

**定义：** 价格偏离均值后，回到一半距离所需的时间

**计算：**
对于 AR(1) 模型 $X_t = \phi X_{t-1} + \varepsilon_t$：
$$
\text{Half-Life} = -\frac{\ln(2)}{\ln(\phi)}
$$

**判断标准：**
- 半衰期越短，均值回复速度越快
- 半衰期过长（如 > 100 天），可能不适合均值回复策略

#### Hurst 指数

**定义：** 衡量时间序列的长期记忆性

**判断标准：**
- $H = 0.5$：随机游走（无均值回复）
- $H < 0.5$：均值回复（反持续性）
- $H > 0.5$：趋势（持续性）

#### ADF 检验（用于均值回复）

对价差序列进行 ADF 检验：
- 如果价差是平稳的，则具有均值回复特性
- 适用于配对交易中的价差检验

---

## 五、在量化交易中的应用

### 5.1 应用场景

| 应用场景 | 平稳性要求 | 均值回复特性 | 策略类型 |
|----------|------------|--------------|----------|
| **AR/ARMA 建模** | ✅ 必须 | 通常有 | 预测策略 |
| **配对交易** | ⚠️ 价差需平稳 | ✅ 必须 | 统计套利 |
| **波动率交易** | ✅ 必须 | ✅ 通常有 | 波动率套利 |
| **价差交易** | ⚠️ 价差需平稳 | ✅ 必须 | 市场中性策略 |
| **期权定价** | ✅ 必须 | - | 衍生品定价 |

### 5.2 平稳性在量化交易中的重要性

1. **模型有效性**
   - AR、MA、ARMA 等模型要求序列平稳
   - 非平稳序列会导致虚假回归（Spurious Regression）

2. **参数估计**
   - 平稳序列的参数估计具有一致性
   - 非平稳序列的参数估计可能不一致

3. **预测可靠性**
   - 只有平稳序列才能进行可靠的预测
   - 非平稳序列的预测误差会随时间增长

### 5.3 均值回复在量化交易中的应用

1. **配对交易（Pairs Trading）**
   - 寻找协整的股票对
   - 当价差偏离均值时，做多被低估的，做空被高估的
   - 等待价差回归均值

2. **统计套利**
   - 利用多个资产之间的价差均值回复
   - 市场中性策略

3. **波动率交易**
   - 波动率通常具有均值回复特性
   - 当波动率偏离历史均值时进行交易

4. **反转策略**
   - 基于短期价格偏离长期均值的反转
   - 适用于均值回复的资产

---

## 六、实战案例与策略

### 6.1 案例1：配对交易

**策略逻辑：**
1. 寻找协整的股票对（如两只同行业股票）
2. 计算价差：$Z_t = \log(P_{1,t}) - \beta \log(P_{2,t})$
3. 检验价差的平稳性（ADF 检验）
4. 当价差偏离均值超过阈值时开仓
5. 当价差回归均值时平仓

**关键点：**
- 价差必须是平稳的（具有均值回复特性）
- 需要动态调整对冲比例 $\beta$

### 6.2 案例2：波动率均值回复交易

**策略逻辑：**
1. 计算历史波动率（如 30 日滚动波动率）
2. 计算长期平均波动率
3. 当当前波动率远高于长期均值时，预期波动率会下降
4. 可以通过卖出期权或波动率衍生品获利

**关键点：**
- 波动率通常具有均值回复特性
- 需要区分短期波动和长期波动

### 6.3 案例3：价差交易

**策略逻辑：**
1. 识别具有长期均衡关系的资产对
2. 计算价差并检验平稳性
3. 当价差偏离均值时建仓
4. 等待价差回归

**示例：**
- 跨期套利（同一资产不同到期日的合约）
- 跨市场套利（同一资产在不同市场的价差）
- 跨品种套利（相关资产之间的价差）

---

## 七、Python 实现

### 7.1 平稳性检验

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller, kpss
import matplotlib.pyplot as plt

def test_stationarity(timeseries, title="时间序列"):
    """
    综合平稳性检验函数
    """
    print(f"\n{'='*60}")
    print(f"{title} - 平稳性检验")
    print(f"{'='*60}")
    
    # 1. ADF 检验
    print("\n1. ADF 检验 (Augmented Dickey-Fuller Test)")
    print("-" * 60)
    adf_result = adfuller(timeseries.dropna())
    print(f'ADF Statistic: {adf_result[0]:.6f}')
    print(f'p-value: {adf_result[1]:.6f}')
    print(f'Critical Values:')
    for key, value in adf_result[4].items():
        print(f'   {key}: {value:.3f}')
    
    if adf_result[1] <= 0.05:
        print("✅ 结论: 序列是平稳的 (拒绝原假设，无单位根)")
    else:
        print("❌ 结论: 序列是非平稳的 (不能拒绝原假设，存在单位根)")
    
    # 2. KPSS 检验
    print("\n2. KPSS 检验")
    print("-" * 60)
    try:
        kpss_result = kpss(timeseries.dropna(), regression='c')
        print(f'KPSS Statistic: {kpss_result[0]:.6f}')
        print(f'p-value: {kpss_result[1]:.6f}')
        print(f'Critical Values:')
        for key, value in kpss_result[3].items():
            print(f'   {key}: {value:.3f}')
        
        if kpss_result[1] >= 0.05:
            print("✅ 结论: 序列是平稳的 (不能拒绝原假设)")
        else:
            print("❌ 结论: 序列是非平稳的 (拒绝原假设)")
    except Exception as e:
        print(f"KPSS 检验失败: {e}")
    
    # 3. 可视化
    fig, axes = plt.subplots(2, 1, figsize=(12, 8))
    
    # 时间序列图
    axes[0].plot(timeseries)
    axes[0].set_title(f'{title} - 时间序列图')
    axes[0].set_xlabel('时间')
    axes[0].set_ylabel('值')
    axes[0].grid(True)
    
    # 滚动统计
    rolling_mean = timeseries.rolling(window=12).mean()
    rolling_std = timeseries.rolling(window=12).std()
    
    axes[1].plot(timeseries, label='原始序列', alpha=0.7)
    axes[1].plot(rolling_mean, label='滚动均值', color='red')
    axes[1].fill_between(rolling_mean.index, 
                         rolling_mean - rolling_std, 
                         rolling_mean + rolling_std, 
                         alpha=0.2, color='red', label='滚动标准差')
    axes[1].set_title(f'{title} - 滚动统计')
    axes[1].set_xlabel('时间')
    axes[1].set_ylabel('值')
    axes[1].legend()
    axes[1].grid(True)
    
    plt.tight_layout()
    plt.show()
    
    return adf_result, kpss_result if 'kpss_result' in locals() else None

# 使用示例
# 生成非平稳序列（随机游走）
np.random.seed(42)
n = 500
random_walk = np.cumsum(np.random.randn(n))
random_walk_series = pd.Series(random_walk)

# 生成平稳序列（AR(1)）
ar1_series = pd.Series(np.zeros(n))
for i in range(1, n):
    ar1_series.iloc[i] = 0.7 * ar1_series.iloc[i-1] + np.random.randn()

# 检验
print("=" * 60)
print("非平稳序列检验（随机游走）")
print("=" * 60)
test_stationarity(random_walk_series, "随机游走")

print("\n" + "=" * 60)
print("平稳序列检验（AR(1)）")
print("=" * 60)
test_stationarity(ar1_series, "AR(1) 过程")
```

### 7.2 均值回复检验

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller
from statsmodels.regression.linear_model import OLS
from statsmodels.tsa.ar_model import AutoReg

def test_mean_reversion(series, max_lag=5):
    """
    均值回复检验
    """
    print(f"\n{'='*60}")
    print("均值回复检验")
    print(f"{'='*60}")
    
    # 1. ADF 检验（价差或序列本身）
    print("\n1. ADF 检验")
    print("-" * 60)
    adf_result = adfuller(series.dropna())
    print(f'ADF Statistic: {adf_result[0]:.6f}')
    print(f'p-value: {adf_result[1]:.6f}')
    
    if adf_result[1] <= 0.05:
        print("✅ 序列具有均值回复特性")
        is_mean_reverting = True
    else:
        print("❌ 序列不具有均值回复特性")
        is_mean_reverting = False
    
    # 2. 估计 AR(1) 模型并计算半衰期
    print("\n2. AR(1) 模型估计与半衰期")
    print("-" * 60)
    try:
        model = AutoReg(series.dropna(), lags=1, trend='c')
        result = model.fit()
        phi = result.params[1]  # AR(1) 系数
        
        print(f'AR(1) 系数 (φ): {phi:.6f}')
        
        if 0 < phi < 1:
            half_life = -np.log(2) / np.log(phi)
            print(f'半衰期: {half_life:.2f} 期')
            
            if half_life < 10:
                print("✅ 均值回复速度很快，适合短期交易")
            elif half_life < 50:
                print("⚠️ 均值回复速度中等，适合中期交易")
            else:
                print("❌ 均值回复速度很慢，可能不适合均值回复策略")
        else:
            print("⚠️ AR(1) 系数不在 (0, 1) 范围内，可能不是均值回复过程")
    except Exception as e:
        print(f"AR(1) 估计失败: {e}")
    
    # 3. Hurst 指数（简化版本）
    print("\n3. Hurst 指数（简化估计）")
    print("-" * 60)
    try:
        def hurst_exponent(ts, max_lag=20):
            """计算 Hurst 指数"""
            lags = range(2, max_lag)
            tau = [np.sqrt(np.std(np.subtract(ts[lag:], ts[:-lag]))) for lag in lags]
            poly = np.polyfit(np.log(lags), np.log(tau), 1)
            return poly[0] * 2.0
        
        H = hurst_exponent(series.dropna().values)
        print(f'Hurst 指数: {H:.4f}')
        
        if H < 0.5:
            print("✅ 序列具有均值回复特性 (H < 0.5)")
        elif H == 0.5:
            print("⚠️ 序列是随机游走 (H = 0.5)")
        else:
            print("❌ 序列具有趋势特性 (H > 0.5)")
    except Exception as e:
        print(f"Hurst 指数计算失败: {e}")
    
    return is_mean_reverting

# 使用示例
# 生成均值回复序列
np.random.seed(42)
n = 500
mean_reverting = pd.Series(np.zeros(n))
mu = 0  # 长期均值
phi = 0.8  # 均值回复系数
for i in range(1, n):
    mean_reverting.iloc[i] = mu + phi * (mean_reverting.iloc[i-1] - mu) + np.random.randn()

test_mean_reversion(mean_reverting)
```

### 7.3 配对交易：协整检验与价差分析

```python
import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.regression.linear_model import OLS
import matplotlib.pyplot as plt

def pairs_trading_analysis(price1, price2, lookback=252):
    """
    配对交易分析：协整检验与价差分析
    """
    print(f"\n{'='*60}")
    print("配对交易分析")
    print(f"{'='*60}")
    
    # 1. 协整检验
    print("\n1. 协整检验 (Engle-Granger)")
    print("-" * 60)
    coint_result = coint(price1, price2)
    print(f'协整统计量: {coint_result[0]:.6f}')
    print(f'p-value: {coint_result[1]:.6f}')
    print(f'Critical Values: {coint_result[2]}')
    
    if coint_result[1] <= 0.05:
        print("✅ 两个序列是协整的，可以进行配对交易")
        is_cointegrated = True
    else:
        print("❌ 两个序列不是协整的，不适合配对交易")
        is_cointegrated = False
    
    # 2. 估计对冲比例（OLS 回归）
    print("\n2. 估计对冲比例")
    print("-" * 60)
    model = OLS(price1, price2).fit()
    beta = model.params[0]
    print(f'对冲比例 (β): {beta:.6f}')
    print(f'R-squared: {model.rsquared:.4f}')
    
    # 3. 计算价差
    spread = price1 - beta * price2
    spread_mean = spread.mean()
    spread_std = spread.std()
    
    print(f'\n价差统计:')
    print(f'均值: {spread_mean:.6f}')
    print(f'标准差: {spread_std:.6f}')
    
    # 4. 价差的平稳性检验
    print("\n3. 价差平稳性检验 (ADF)")
    print("-" * 60)
    adf_result = adfuller(spread.dropna())
    print(f'ADF Statistic: {adf_result[0]:.6f}')
    print(f'p-value: {adf_result[1]:.6f}')
    
    if adf_result[1] <= 0.05:
        print("✅ 价差是平稳的，具有均值回复特性")
    else:
        print("❌ 价差是非平稳的")
    
    # 5. 可视化
    fig, axes = plt.subplots(3, 1, figsize=(14, 10))
    
    # 价格序列
    axes[0].plot(price1.index, price1.values, label='资产1', alpha=0.7)
    axes[0].plot(price2.index, price2.values, label='资产2', alpha=0.7)
    axes[0].set_title('价格序列')
    axes[0].set_ylabel('价格')
    axes[0].legend()
    axes[0].grid(True)
    
    # 价差
    axes[1].plot(spread.index, spread.values, label='价差', color='green', alpha=0.7)
    axes[1].axhline(y=spread_mean, color='red', linestyle='--', label='均值')
    axes[1].axhline(y=spread_mean + 2*spread_std, color='orange', linestyle='--', label='±2σ')
    axes[1].axhline(y=spread_mean - 2*spread_std, color='orange', linestyle='--')
    axes[1].fill_between(spread.index, 
                         spread_mean - 2*spread_std, 
                         spread_mean + 2*spread_std, 
                         alpha=0.1, color='orange')
    axes[1].set_title('价差序列')
    axes[1].set_ylabel('价差')
    axes[1].legend()
    axes[1].grid(True)
    
    # 价差分布
    axes[2].hist(spread.dropna(), bins=50, alpha=0.7, edgecolor='black')
    axes[2].axvline(x=spread_mean, color='red', linestyle='--', label='均值')
    axes[2].set_title('价差分布')
    axes[2].set_xlabel('价差')
    axes[2].set_ylabel('频数')
    axes[2].legend()
    axes[2].grid(True)
    
    plt.tight_layout()
    plt.show()
    
    return {
        'is_cointegrated': is_cointegrated,
        'beta': beta,
        'spread': spread,
        'spread_mean': spread_mean,
        'spread_std': spread_std
    }

# 使用示例
# 生成两个协整的价格序列
np.random.seed(42)
n = 500

# 生成共同因子
common_factor = np.cumsum(np.random.randn(n))

# 生成两个价格序列（具有协整关系）
price1 = pd.Series(common_factor + 0.5 * np.random.randn(n))
price2 = pd.Series(0.8 * common_factor + 0.3 * np.random.randn(n))
price1.index = pd.date_range('2020-01-01', periods=n, freq='D')
price2.index = price1.index

result = pairs_trading_analysis(price1, price2)
```

### 7.4 均值回复策略示例

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def mean_reversion_strategy(price_series, lookback=20, entry_threshold=2, exit_threshold=0.5):
    """
    简单的均值回复策略
    
    参数:
        price_series: 价格序列
        lookback: 计算均值和标准差的窗口长度
        entry_threshold: 开仓阈值（标准差倍数）
        exit_threshold: 平仓阈值（标准差倍数）
    """
    # 计算滚动统计
    rolling_mean = price_series.rolling(window=lookback).mean()
    rolling_std = price_series.rolling(window=lookback).std()
    
    # 计算 Z-score
    z_score = (price_series - rolling_mean) / rolling_std
    
    # 生成信号
    signals = pd.Series(0, index=price_series.index)
    positions = pd.Series(0, index=price_series.index)
    
    current_position = 0
    
    for i in range(lookback, len(price_series)):
        if current_position == 0:  # 无持仓
            if z_score.iloc[i] > entry_threshold:
                signals.iloc[i] = -1  # 卖出信号（价格过高）
                current_position = -1
            elif z_score.iloc[i] < -entry_threshold:
                signals.iloc[i] = 1  # 买入信号（价格过低）
                current_position = 1
        elif current_position == -1:  # 持有空头
            if z_score.iloc[i] < exit_threshold:
                signals.iloc[i] = 1  # 平仓信号
                current_position = 0
        elif current_position == 1:  # 持有多头
            if z_score.iloc[i] > -exit_threshold:
                signals.iloc[i] = -1  # 平仓信号
                current_position = 0
        
        positions.iloc[i] = current_position
    
    # 计算收益
    returns = price_series.pct_change()
    strategy_returns = positions.shift(1) * returns
    cumulative_returns = (1 + strategy_returns).cumprod()
    
    # 可视化
    fig, axes = plt.subplots(3, 1, figsize=(14, 10))
    
    # 价格和信号
    axes[0].plot(price_series.index, price_series.values, label='价格', alpha=0.7)
    axes[0].plot(rolling_mean.index, rolling_mean.values, label='滚动均值', color='red', linestyle='--')
    buy_signals = price_series[signals == 1]
    sell_signals = price_series[signals == -1]
    axes[0].scatter(buy_signals.index, buy_signals.values, color='green', marker='^', s=100, label='买入')
    axes[0].scatter(sell_signals.index, sell_signals.values, color='red', marker='v', s=100, label='卖出')
    axes[0].set_title('价格与交易信号')
    axes[0].set_ylabel('价格')
    axes[0].legend()
    axes[0].grid(True)
    
    # Z-score
    axes[1].plot(z_score.index, z_score.values, label='Z-score', color='blue', alpha=0.7)
    axes[1].axhline(y=entry_threshold, color='red', linestyle='--', label=f'开仓阈值 ±{entry_threshold}')
    axes[1].axhline(y=-entry_threshold, color='red', linestyle='--')
    axes[1].axhline(y=exit_threshold, color='green', linestyle='--', label=f'平仓阈值 ±{exit_threshold}')
    axes[1].axhline(y=-exit_threshold, color='green', linestyle='--')
    axes[1].axhline(y=0, color='black', linestyle='-', alpha=0.3)
    axes[1].fill_between(z_score.index, -entry_threshold, entry_threshold, alpha=0.1, color='green')
    axes[1].set_title('Z-score')
    axes[1].set_ylabel('Z-score')
    axes[1].legend()
    axes[1].grid(True)
    
    # 累计收益
    axes[2].plot(cumulative_returns.index, cumulative_returns.values, label='策略收益', color='green')
    buy_hold_returns = (1 + returns).cumprod()
    axes[2].plot(buy_hold_returns.index, buy_hold_returns.values, label='买入持有', color='blue', alpha=0.7)
    axes[2].set_title('累计收益')
    axes[2].set_ylabel('累计收益')
    axes[2].set_xlabel('时间')
    axes[2].legend()
    axes[2].grid(True)
    
    plt.tight_layout()
    plt.show()
    
    # 性能统计
    total_return = cumulative_returns.iloc[-1] - 1
    sharpe_ratio = strategy_returns.mean() / strategy_returns.std() * np.sqrt(252) if strategy_returns.std() > 0 else 0
    
    print(f"\n策略性能:")
    print(f"总收益率: {total_return:.2%}")
    print(f"年化夏普比率: {sharpe_ratio:.2f}")
    print(f"交易次数: {abs(signals).sum()}")
    
    return {
        'signals': signals,
        'positions': positions,
        'returns': strategy_returns,
        'cumulative_returns': cumulative_returns
    }

# 使用示例
# 生成均值回复的价格序列
np.random.seed(42)
n = 500
prices = pd.Series(np.zeros(n))
mu = 100  # 长期均值价格
phi = 0.95  # 均值回复系数
for i in range(1, n):
    prices.iloc[i] = mu + phi * (prices.iloc[i-1] - mu) + np.random.randn()
prices.index = pd.date_range('2020-01-01', periods=n, freq='D')

result = mean_reversion_strategy(prices, lookback=20, entry_threshold=2, exit_threshold=0.5)
```

---

## 总结

### 核心要点

1. **平稳性**是时间序列分析的基础，要求序列的统计特性不随时间变化
2. **均值回复**是价格围绕长期均值波动的特性，是许多量化策略的基础
3. **平稳性是均值回复的充分条件**，平稳序列通常具有均值回复特性
4. **检验方法**包括 ADF 检验、KPSS 检验、半衰期、Hurst 指数等

### 在量化交易中的定位

- ✅ **平稳性**：AR/ARMA 模型的前提，确保模型有效性
- ✅ **均值回复**：配对交易、统计套利、反转策略的基础
- ⚠️ **注意事项**：不是所有资产都适合均值回复策略，需要充分检验

### 关键注意事项

1. **数据预处理**：非平稳序列需要差分或对数变换
2. **充分检验**：使用多种方法检验平稳性和均值回复特性
3. **动态调整**：市场环境变化时，需要重新检验和调整策略
4. **风险管理**：均值回复策略可能面临长期偏离的风险

---

*平稳性与均值回复是量化交易中的核心概念，理解它们对于构建有效的交易策略至关重要。*

